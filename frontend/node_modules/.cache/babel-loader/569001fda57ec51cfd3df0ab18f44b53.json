{"ast":null,"code":"/**\n *  @since 4.0.0 This class has been split\n *\n * @typedef {Object} RegionsPluginParams\n * @property {?boolean} dragSelection Enable creating regions by dragging with\n * the mouse\n * @property {?boolean} contentEditable=false Allow/disallow editing content of the region\n * @property {?boolean} removeButton=false adds remove region button\n * @property {?RegionParams[]} regions Regions that should be added upon\n * initialisation\n * @property {number} slop=2 The sensitivity of the mouse dragging\n * @property {?number} snapToGridInterval Snap the regions to a grid of the specified multiples in seconds\n * @property {?number} snapToGridOffset Shift the snap-to-grid by the specified seconds. May also be negative.\n * @property {?boolean} deferInit Set to true to manually call\n * @property {number} maxRegions Maximum number of regions that may be created by the user at one time.\n * `initPlugin('regions')`\n * @property {function} formatTimeCallback Allows custom formating for region tooltip.\n * @property {?number} edgeScrollWidth='5% from container edges' Optional width for edgeScroll to start\n */\n\n/**\n * @typedef {Object} RegionParams\n * @desc The parameters used to describe a region.\n * @example wavesurfer.addRegion(regionParams);\n * @property {string} id=→random The id of the region\n * @property {number} start=0 The start position of the region (in seconds).\n * @property {number} end=0 The end position of the region (in seconds).\n * @property {?boolean} loop Whether to loop the region when played back.\n * @property {boolean} drag=true Allow/disallow dragging the region.\n * @property {boolean} resize=true Allow/disallow resizing the region.\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\n * @property {?number} channelIdx Select channel to draw the region on (if there are multiple channel waveforms).\n * @property {?object} handleStyle A set of CSS properties used to style the left and right handle.\n * @property {?boolean} preventContextMenu=false Determines whether the context menu is prevented from being opened.\n * @property {boolean} showTooltip=true Enable/disable tooltip displaying start and end times when hovering over region.\n */\nimport { Region } from \"./region.js\";\n/**\n * Regions are visual overlays on waveform that can be used to play and loop\n * portions of audio. Regions can be dragged and resized.\n *\n * Visual customization is possible via CSS (using the selectors\n * `.wavesurfer-region` and `.wavesurfer-handle`).\n *\n * @implements {PluginClass}\n * @extends {Observer}\n *\n * @example\n * // es6\n * import RegionsPlugin from 'wavesurfer.regions.js';\n *\n * // commonjs\n * var RegionsPlugin = require('wavesurfer.regions.js');\n *\n * // if you are using <script> tags\n * var RegionsPlugin = window.WaveSurfer.regions;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     RegionsPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\n\nexport default class RegionsPlugin {\n  /**\n   * Regions plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wavesurfer to correctly instantiate the plugin.\n   *\n   * @param {RegionsPluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params) {\n    return {\n      name: 'regions',\n      deferInit: params && params.deferInit ? params.deferInit : false,\n      params: params,\n      staticProps: {\n        addRegion(options) {\n          if (!this.initialisedPluginList.regions) {\n            this.initPlugin('regions');\n          }\n\n          return this.regions.add(options);\n        },\n\n        clearRegions() {\n          this.regions && this.regions.clear();\n        },\n\n        enableDragSelection(options) {\n          if (!this.initialisedPluginList.regions) {\n            this.initPlugin('regions');\n          }\n\n          this.regions.enableDragSelection(options);\n        },\n\n        disableDragSelection() {\n          this.regions.disableDragSelection();\n        }\n\n      },\n      instance: RegionsPlugin\n    };\n  }\n\n  constructor(params, ws) {\n    this.params = params;\n    this.wavesurfer = ws;\n    this.util = { ...ws.util,\n      getRegionSnapToGridValue: value => {\n        return this.getRegionSnapToGridValue(value, params);\n      }\n    };\n    this.maxRegions = params.maxRegions;\n    this.regionsMinLength = params.regionsMinLength || null; // turn the plugin instance into an observer\n\n    const observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);\n    observerPrototypeKeys.forEach(key => {\n      Region.prototype[key] = this.util.Observer.prototype[key];\n    });\n    this.wavesurfer.Region = Region; // By default, scroll the container if the user drags a region\n    // within 5% (based on its initial size) of its edge\n\n    const scrollWidthProportion = 0.05;\n\n    this._onBackendCreated = () => {\n      this.wrapper = this.wavesurfer.drawer.wrapper;\n      this.orientation = this.wavesurfer.drawer.orientation;\n      this.defaultEdgeScrollWidth = this.wrapper.clientWidth * scrollWidthProportion;\n\n      if (this.params.regions) {\n        this.params.regions.forEach(region => {\n          this.add(region);\n        });\n      }\n    }; // Id-based hash of regions\n\n\n    this.list = {};\n\n    this._onReady = () => {\n      this.wrapper = this.wavesurfer.drawer.wrapper;\n      this.vertical = this.wavesurfer.drawer.params.vertical;\n\n      if (this.params.dragSelection) {\n        this.enableDragSelection(this.params);\n      }\n\n      Object.keys(this.list).forEach(id => {\n        this.list[id].updateRender();\n      });\n    };\n  }\n\n  init() {\n    // Check if ws is ready\n    if (this.wavesurfer.isReady) {\n      this._onBackendCreated();\n\n      this._onReady();\n    } else {\n      this.wavesurfer.once('ready', this._onReady);\n      this.wavesurfer.once('backend-created', this._onBackendCreated);\n    }\n  }\n\n  destroy() {\n    this.wavesurfer.un('ready', this._onReady);\n    this.wavesurfer.un('backend-created', this._onBackendCreated); // Disabling `region-removed' because destroying the plugin calls\n    // the Region.remove() method that is also used to remove regions based\n    // on user input. This can cause confusion since teardown is not a\n    // user event, but would emit `region-removed` as if it was.\n\n    this.wavesurfer.setDisabledEventEmissions(['region-removed']);\n    this.disableDragSelection();\n    this.clear();\n  }\n  /**\n   * check to see if adding a new region would exceed maxRegions\n   * @return {boolean} whether we should proceed and create a region\n   * @private\n   */\n\n\n  wouldExceedMaxRegions() {\n    return this.maxRegions && Object.keys(this.list).length >= this.maxRegions;\n  }\n  /**\n   * Add a region\n   *\n   * @param {object} params Region parameters\n   * @return {Region} The created region\n   */\n\n\n  add(params) {\n    if (this.wouldExceedMaxRegions()) {\n      return null;\n    }\n\n    params = {\n      edgeScrollWidth: this.params.edgeScrollWidth || this.defaultEdgeScrollWidth,\n      contentEditable: this.params.contentEditable,\n      removeButton: this.params.removeButton,\n      ...params\n    }; // Take formatTimeCallback from plugin params if not already set\n\n    if (!params.formatTimeCallback && this.params.formatTimeCallback) {\n      params = { ...params,\n        formatTimeCallback: this.params.formatTimeCallback\n      };\n    }\n\n    if (!params.minLength && this.regionsMinLength) {\n      params = { ...params,\n        minLength: this.regionsMinLength\n      };\n    }\n\n    const region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);\n    this.list[region.id] = region;\n    region.on('remove', () => {\n      delete this.list[region.id];\n    });\n    return region;\n  }\n  /**\n   * Remove all regions\n   */\n\n\n  clear() {\n    Object.keys(this.list).forEach(id => {\n      this.list[id].remove();\n    });\n  }\n\n  enableDragSelection(params) {\n    this.disableDragSelection();\n    const slop = params.slop || 2;\n    const container = this.wavesurfer.drawer.container;\n    const scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;\n    const scrollSpeed = params.scrollSpeed || 1;\n    const scrollThreshold = params.scrollThreshold || 10;\n    let drag;\n    let duration = this.wavesurfer.getDuration();\n    let maxScroll;\n    let start;\n    let region;\n    let touchId;\n    let pxMove = 0;\n    let scrollDirection;\n    let wrapperRect; // Scroll when the user is dragging within the threshold\n\n    const edgeScroll = e => {\n      if (!region || !scrollDirection) {\n        return;\n      } // Update scroll position\n\n\n      let scrollLeft = this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n      this.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range\n\n      const end = this.wavesurfer.drawer.handleEvent(e);\n      region.update({\n        start: Math.min(end * duration, start * duration),\n        end: Math.max(end * duration, start * duration)\n      }); // Check that there is more to scroll and repeat\n\n      if (scrollLeft < maxScroll && scrollLeft > 0) {\n        window.requestAnimationFrame(() => {\n          edgeScroll(e);\n        });\n      }\n    };\n\n    const eventDown = e => {\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      duration = this.wavesurfer.getDuration();\n      touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations\n\n      maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n      wrapperRect = this.util.withOrientation(this.wrapper.getBoundingClientRect(), this.vertical); // set the region channel index based on the clicked area\n\n      if (this.wavesurfer.params.splitChannels && this.wavesurfer.params.splitChannelsOptions.splitDragSelection) {\n        const y = (e.touches ? e.touches[0].clientY : e.clientY) - wrapperRect.top;\n        const channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : 1;\n        const channelHeight = this.wrapper.clientHeight / channelCount;\n        const channelIdx = Math.floor(y / channelHeight);\n        params.channelIdx = channelIdx;\n        const channelColors = this.wavesurfer.params.splitChannelsOptions.channelColors[channelIdx];\n\n        if (channelColors && channelColors.dragColor) {\n          params.color = channelColors.dragColor;\n        }\n      }\n\n      drag = true;\n      start = this.wavesurfer.drawer.handleEvent(e, true);\n      region = null;\n      scrollDirection = null;\n    };\n\n    this.wrapper.addEventListener('mousedown', eventDown);\n    this.wrapper.addEventListener('touchstart', eventDown);\n    this.on('disable-drag-selection', () => {\n      this.wrapper.removeEventListener('touchstart', eventDown);\n      this.wrapper.removeEventListener('mousedown', eventDown);\n    });\n\n    const eventUp = e => {\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      drag = false;\n      pxMove = 0;\n      scrollDirection = null;\n\n      if (region) {\n        this.util.preventClick();\n        region.fireEvent('update-end', e);\n        this.wavesurfer.fireEvent('region-update-end', region, e);\n      }\n\n      region = null;\n    };\n\n    this.wrapper.addEventListener('mouseleave', eventUp);\n    this.wrapper.addEventListener('mouseup', eventUp);\n    this.wrapper.addEventListener('touchend', eventUp);\n    document.body.addEventListener('mouseup', eventUp);\n    document.body.addEventListener('touchend', eventUp);\n    this.on('disable-drag-selection', () => {\n      document.body.removeEventListener('mouseup', eventUp);\n      document.body.removeEventListener('touchend', eventUp);\n      this.wrapper.removeEventListener('touchend', eventUp);\n      this.wrapper.removeEventListener('mouseup', eventUp);\n      this.wrapper.removeEventListener('mouseleave', eventUp);\n    });\n\n    const eventMove = event => {\n      if (!drag) {\n        return;\n      }\n\n      if (++pxMove <= slop) {\n        return;\n      }\n\n      if (event.touches && event.touches.length > 1) {\n        return;\n      }\n\n      if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n        return;\n      } // auto-create a region during mouse drag, unless region-count would exceed \"maxRegions\"\n\n\n      if (!region) {\n        region = this.add(params || {});\n\n        if (!region) {\n          return;\n        }\n      }\n\n      const end = this.wavesurfer.drawer.handleEvent(event);\n      const startUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(start * duration);\n      const endUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(end * duration);\n      region.update({\n        start: Math.min(endUpdate, startUpdate),\n        end: Math.max(endUpdate, startUpdate)\n      });\n      let orientedEvent = this.util.withOrientation(event, this.vertical); // If scrolling is enabled\n\n      if (scroll && container.clientWidth < this.wrapper.scrollWidth) {\n        // Check threshold based on mouse\n        const x = orientedEvent.clientX - wrapperRect.left;\n\n        if (x <= scrollThreshold) {\n          scrollDirection = -1;\n        } else if (x >= wrapperRect.right - scrollThreshold) {\n          scrollDirection = 1;\n        } else {\n          scrollDirection = null;\n        }\n\n        scrollDirection && edgeScroll(event);\n      }\n    };\n\n    this.wrapper.addEventListener('mousemove', eventMove);\n    this.wrapper.addEventListener('touchmove', eventMove);\n    this.on('disable-drag-selection', () => {\n      this.wrapper.removeEventListener('touchmove', eventMove);\n      this.wrapper.removeEventListener('mousemove', eventMove);\n    });\n    this.wavesurfer.on('region-created', region => {\n      if (this.regionsMinLength) {\n        region.minLength = this.regionsMinLength;\n      }\n    });\n  }\n\n  disableDragSelection() {\n    this.fireEvent('disable-drag-selection');\n  }\n  /**\n   * Get current region\n   *\n   * The smallest region that contains the current time. If several such\n   * regions exist, take the first. Return `null` if none exist.\n   *\n   * @returns {Region} The current region\n   */\n\n\n  getCurrentRegion() {\n    const time = this.wavesurfer.getCurrentTime();\n    let min = null;\n    Object.keys(this.list).forEach(id => {\n      const cur = this.list[id];\n\n      if (cur.start <= time && cur.end >= time) {\n        if (!min || cur.end - cur.start < min.end - min.start) {\n          min = cur;\n        }\n      }\n    });\n    return min;\n  }\n  /**\n   * Match the value to the grid, if required\n   *\n   * If the regions plugin params have a snapToGridInterval set, return the\n   * value matching the nearest grid interval. If no snapToGridInterval is set,\n   * the passed value will be returned without modification.\n   *\n   * @param {number} value the value to snap to the grid, if needed\n   * @param {Object} params the regions plugin params\n   * @returns {number} value\n   */\n\n\n  getRegionSnapToGridValue(value, params) {\n    if (params.snapToGridInterval) {\n      // the regions should snap to a grid\n      const offset = params.snapToGridOffset || 0;\n      return Math.round((value - offset) / params.snapToGridInterval) * params.snapToGridInterval + offset;\n    } // no snap-to-grid\n\n\n    return value;\n  }\n\n}","map":{"version":3,"sources":["/Users/niteshsingh/Desktop/Voimo/frontend/node_modules/wavesurfer.js/src/plugin/regions/index.js"],"names":["Region","RegionsPlugin","create","params","name","deferInit","staticProps","addRegion","options","initialisedPluginList","regions","initPlugin","add","clearRegions","clear","enableDragSelection","disableDragSelection","instance","constructor","ws","wavesurfer","util","getRegionSnapToGridValue","value","maxRegions","regionsMinLength","observerPrototypeKeys","Object","getOwnPropertyNames","Observer","prototype","forEach","key","scrollWidthProportion","_onBackendCreated","wrapper","drawer","orientation","defaultEdgeScrollWidth","clientWidth","region","list","_onReady","vertical","dragSelection","keys","id","updateRender","init","isReady","once","destroy","un","setDisabledEventEmissions","wouldExceedMaxRegions","length","edgeScrollWidth","contentEditable","removeButton","formatTimeCallback","minLength","on","remove","slop","container","scroll","scrollParent","scrollSpeed","scrollThreshold","drag","duration","getDuration","maxScroll","start","touchId","pxMove","scrollDirection","wrapperRect","edgeScroll","e","scrollLeft","Math","min","max","end","handleEvent","update","window","requestAnimationFrame","eventDown","touches","targetTouches","identifier","scrollWidth","withOrientation","getBoundingClientRect","splitChannels","splitChannelsOptions","splitDragSelection","y","clientY","top","channelCount","backend","buffer","numberOfChannels","channelHeight","clientHeight","channelIdx","floor","channelColors","dragColor","color","addEventListener","removeEventListener","eventUp","preventClick","fireEvent","document","body","eventMove","event","startUpdate","endUpdate","orientedEvent","x","clientX","left","right","getCurrentRegion","time","getCurrentTime","cur","snapToGridInterval","offset","snapToGridOffset","round"],"mappings":"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","sourcesContent":["/**\n *  @since 4.0.0 This class has been split\n *\n * @typedef {Object} RegionsPluginParams\n * @property {?boolean} dragSelection Enable creating regions by dragging with\n * the mouse\n * @property {?boolean} contentEditable=false Allow/disallow editing content of the region\n * @property {?boolean} removeButton=false adds remove region button\n * @property {?RegionParams[]} regions Regions that should be added upon\n * initialisation\n * @property {number} slop=2 The sensitivity of the mouse dragging\n * @property {?number} snapToGridInterval Snap the regions to a grid of the specified multiples in seconds\n * @property {?number} snapToGridOffset Shift the snap-to-grid by the specified seconds. May also be negative.\n * @property {?boolean} deferInit Set to true to manually call\n * @property {number} maxRegions Maximum number of regions that may be created by the user at one time.\n * `initPlugin('regions')`\n * @property {function} formatTimeCallback Allows custom formating for region tooltip.\n * @property {?number} edgeScrollWidth='5% from container edges' Optional width for edgeScroll to start\n */\n\n/**\n * @typedef {Object} RegionParams\n * @desc The parameters used to describe a region.\n * @example wavesurfer.addRegion(regionParams);\n * @property {string} id=→random The id of the region\n * @property {number} start=0 The start position of the region (in seconds).\n * @property {number} end=0 The end position of the region (in seconds).\n * @property {?boolean} loop Whether to loop the region when played back.\n * @property {boolean} drag=true Allow/disallow dragging the region.\n * @property {boolean} resize=true Allow/disallow resizing the region.\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\n * @property {?number} channelIdx Select channel to draw the region on (if there are multiple channel waveforms).\n * @property {?object} handleStyle A set of CSS properties used to style the left and right handle.\n * @property {?boolean} preventContextMenu=false Determines whether the context menu is prevented from being opened.\n * @property {boolean} showTooltip=true Enable/disable tooltip displaying start and end times when hovering over region.\n */\n\nimport {Region} from \"./region.js\";\n\n/**\n * Regions are visual overlays on waveform that can be used to play and loop\n * portions of audio. Regions can be dragged and resized.\n *\n * Visual customization is possible via CSS (using the selectors\n * `.wavesurfer-region` and `.wavesurfer-handle`).\n *\n * @implements {PluginClass}\n * @extends {Observer}\n *\n * @example\n * // es6\n * import RegionsPlugin from 'wavesurfer.regions.js';\n *\n * // commonjs\n * var RegionsPlugin = require('wavesurfer.regions.js');\n *\n * // if you are using <script> tags\n * var RegionsPlugin = window.WaveSurfer.regions;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     RegionsPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class RegionsPlugin {\n    /**\n     * Regions plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param {RegionsPluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    static create(params) {\n        return {\n            name: 'regions',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            staticProps: {\n                addRegion(options) {\n                    if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                    }\n                    return this.regions.add(options);\n                },\n\n                clearRegions() {\n                    this.regions && this.regions.clear();\n                },\n\n                enableDragSelection(options) {\n                    if (!this.initialisedPluginList.regions) {\n                        this.initPlugin('regions');\n                    }\n                    this.regions.enableDragSelection(options);\n                },\n\n                disableDragSelection() {\n                    this.regions.disableDragSelection();\n                }\n            },\n            instance: RegionsPlugin\n        };\n    }\n\n    constructor(params, ws) {\n        this.params = params;\n        this.wavesurfer = ws;\n        this.util = {\n            ...ws.util,\n            getRegionSnapToGridValue: value => {\n                return this.getRegionSnapToGridValue(value, params);\n            }\n        };\n        this.maxRegions = params.maxRegions;\n        this.regionsMinLength = params.regionsMinLength || null;\n\n        // turn the plugin instance into an observer\n        const observerPrototypeKeys = Object.getOwnPropertyNames(\n            this.util.Observer.prototype\n        );\n        observerPrototypeKeys.forEach(key => {\n            Region.prototype[key] = this.util.Observer.prototype[key];\n        });\n        this.wavesurfer.Region = Region;\n\n        // By default, scroll the container if the user drags a region\n        // within 5% (based on its initial size) of its edge\n        const scrollWidthProportion = 0.05;\n        this._onBackendCreated = () => {\n            this.wrapper = this.wavesurfer.drawer.wrapper;\n            this.orientation = this.wavesurfer.drawer.orientation;\n            this.defaultEdgeScrollWidth = this.wrapper.clientWidth * scrollWidthProportion;\n            if (this.params.regions) {\n                this.params.regions.forEach(region => {\n                    this.add(region);\n                });\n            }\n        };\n\n        // Id-based hash of regions\n        this.list = {};\n        this._onReady = () => {\n            this.wrapper = this.wavesurfer.drawer.wrapper;\n            this.vertical = this.wavesurfer.drawer.params.vertical;\n            if (this.params.dragSelection) {\n                this.enableDragSelection(this.params);\n            }\n            Object.keys(this.list).forEach(id => {\n                this.list[id].updateRender();\n            });\n        };\n    }\n\n    init() {\n        // Check if ws is ready\n        if (this.wavesurfer.isReady) {\n            this._onBackendCreated();\n            this._onReady();\n        } else {\n            this.wavesurfer.once('ready', this._onReady);\n            this.wavesurfer.once('backend-created', this._onBackendCreated);\n        }\n    }\n\n    destroy() {\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.un('backend-created', this._onBackendCreated);\n        // Disabling `region-removed' because destroying the plugin calls\n        // the Region.remove() method that is also used to remove regions based\n        // on user input. This can cause confusion since teardown is not a\n        // user event, but would emit `region-removed` as if it was.\n        this.wavesurfer.setDisabledEventEmissions(['region-removed']);\n        this.disableDragSelection();\n        this.clear();\n    }\n\n    /**\n     * check to see if adding a new region would exceed maxRegions\n     * @return {boolean} whether we should proceed and create a region\n     * @private\n     */\n    wouldExceedMaxRegions() {\n        return (\n            this.maxRegions && Object.keys(this.list).length >= this.maxRegions\n        );\n    }\n\n    /**\n     * Add a region\n     *\n     * @param {object} params Region parameters\n     * @return {Region} The created region\n     */\n    add(params) {\n        if (this.wouldExceedMaxRegions()) {\n            return null;\n        }\n\n        params = {\n            edgeScrollWidth: this.params.edgeScrollWidth || this.defaultEdgeScrollWidth,\n            contentEditable: this.params.contentEditable,\n            removeButton: this.params.removeButton,\n            ...params\n        };\n\n        // Take formatTimeCallback from plugin params if not already set\n        if (!params.formatTimeCallback && this.params.formatTimeCallback) {\n            params = {...params, formatTimeCallback: this.params.formatTimeCallback};\n        }\n\n        if (!params.minLength && this.regionsMinLength) {\n            params = {...params, minLength: this.regionsMinLength};\n        }\n\n        const region = new this.wavesurfer.Region(params, this.util, this.wavesurfer);\n\n        this.list[region.id] = region;\n\n        region.on('remove', () => {\n            delete this.list[region.id];\n        });\n\n        return region;\n    }\n\n    /**\n     * Remove all regions\n     */\n    clear() {\n        Object.keys(this.list).forEach(id => {\n            this.list[id].remove();\n        });\n    }\n\n    enableDragSelection(params) {\n        this.disableDragSelection();\n\n        const slop = params.slop || 2;\n        const container = this.wavesurfer.drawer.container;\n        const scroll =\n            params.scroll !== false && this.wavesurfer.params.scrollParent;\n        const scrollSpeed = params.scrollSpeed || 1;\n        const scrollThreshold = params.scrollThreshold || 10;\n        let drag;\n        let duration = this.wavesurfer.getDuration();\n        let maxScroll;\n        let start;\n        let region;\n        let touchId;\n        let pxMove = 0;\n        let scrollDirection;\n        let wrapperRect;\n\n        // Scroll when the user is dragging within the threshold\n        const edgeScroll = e => {\n            if (!region || !scrollDirection) {\n                return;\n            }\n\n            // Update scroll position\n            let scrollLeft =\n                this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n            this.wrapper.scrollLeft = scrollLeft = Math.min(\n                maxScroll,\n                Math.max(0, scrollLeft)\n            );\n\n            // Update range\n            const end = this.wavesurfer.drawer.handleEvent(e);\n            region.update({\n                start: Math.min(end * duration, start * duration),\n                end: Math.max(end * duration, start * duration)\n            });\n\n            // Check that there is more to scroll and repeat\n            if (scrollLeft < maxScroll && scrollLeft > 0) {\n                window.requestAnimationFrame(() => {\n                    edgeScroll(e);\n                });\n            }\n        };\n\n        const eventDown = e => {\n            if (e.touches && e.touches.length > 1) {\n                return;\n            }\n            duration = this.wavesurfer.getDuration();\n            touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\n\n            // Store for scroll calculations\n            maxScroll = this.wrapper.scrollWidth -\n                this.wrapper.clientWidth;\n            wrapperRect = this.util.withOrientation(\n                this.wrapper.getBoundingClientRect(),\n                this.vertical\n            );\n\n            // set the region channel index based on the clicked area\n            if (this.wavesurfer.params.splitChannels && this.wavesurfer.params.splitChannelsOptions.splitDragSelection) {\n                const y = (e.touches ? e.touches[0].clientY : e.clientY) - wrapperRect.top;\n                const channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : 1;\n                const channelHeight = this.wrapper.clientHeight / channelCount;\n                const channelIdx = Math.floor(y / channelHeight);\n                params.channelIdx = channelIdx;\n                const channelColors = this.wavesurfer.params.splitChannelsOptions.channelColors[channelIdx];\n                if (channelColors && channelColors.dragColor) {\n                    params.color = channelColors.dragColor;\n                }\n            }\n\n            drag = true;\n            start = this.wavesurfer.drawer.handleEvent(e, true);\n            region = null;\n            scrollDirection = null;\n        };\n        this.wrapper.addEventListener('mousedown', eventDown);\n        this.wrapper.addEventListener('touchstart', eventDown);\n        this.on('disable-drag-selection', () => {\n            this.wrapper.removeEventListener('touchstart', eventDown);\n            this.wrapper.removeEventListener('mousedown', eventDown);\n        });\n\n        const eventUp = e => {\n            if (e.touches && e.touches.length > 1) {\n                return;\n            }\n\n            drag = false;\n            pxMove = 0;\n            scrollDirection = null;\n\n            if (region) {\n                this.util.preventClick();\n                region.fireEvent('update-end', e);\n                this.wavesurfer.fireEvent('region-update-end', region, e);\n            }\n\n            region = null;\n        };\n        this.wrapper.addEventListener('mouseleave', eventUp);\n        this.wrapper.addEventListener('mouseup', eventUp);\n        this.wrapper.addEventListener('touchend', eventUp);\n\n        document.body.addEventListener('mouseup', eventUp);\n        document.body.addEventListener('touchend', eventUp);\n        this.on('disable-drag-selection', () => {\n            document.body.removeEventListener('mouseup', eventUp);\n            document.body.removeEventListener('touchend', eventUp);\n            this.wrapper.removeEventListener('touchend', eventUp);\n            this.wrapper.removeEventListener('mouseup', eventUp);\n            this.wrapper.removeEventListener('mouseleave', eventUp);\n        });\n\n        const eventMove = event => {\n            if (!drag) {\n                return;\n            }\n            if (++pxMove <= slop) {\n                return;\n            }\n\n            if (event.touches && event.touches.length > 1) {\n                return;\n            }\n            if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n                return;\n            }\n\n            // auto-create a region during mouse drag, unless region-count would exceed \"maxRegions\"\n            if (!region) {\n                region = this.add(params || {});\n                if (!region) {\n                    return;\n                }\n            }\n\n            const end = this.wavesurfer.drawer.handleEvent(event);\n            const startUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(\n                start * duration\n            );\n            const endUpdate = this.wavesurfer.regions.util.getRegionSnapToGridValue(\n                end * duration\n            );\n            region.update({\n                start: Math.min(endUpdate, startUpdate),\n                end: Math.max(endUpdate, startUpdate)\n            });\n\n            let orientedEvent = this.util.withOrientation(event, this.vertical);\n\n            // If scrolling is enabled\n            if (scroll && container.clientWidth < this.wrapper.scrollWidth) {\n                // Check threshold based on mouse\n                const x = orientedEvent.clientX - wrapperRect.left;\n                if (x <= scrollThreshold) {\n                    scrollDirection = -1;\n                } else if (x >= wrapperRect.right - scrollThreshold) {\n                    scrollDirection = 1;\n                } else {\n                    scrollDirection = null;\n                }\n                scrollDirection && edgeScroll(event);\n            }\n        };\n        this.wrapper.addEventListener('mousemove', eventMove);\n        this.wrapper.addEventListener('touchmove', eventMove);\n        this.on('disable-drag-selection', () => {\n            this.wrapper.removeEventListener('touchmove', eventMove);\n            this.wrapper.removeEventListener('mousemove', eventMove);\n        });\n\n        this.wavesurfer.on('region-created', region => {\n            if (this.regionsMinLength) {\n                region.minLength = this.regionsMinLength;\n            }\n        });\n    }\n\n    disableDragSelection() {\n        this.fireEvent('disable-drag-selection');\n    }\n\n    /**\n     * Get current region\n     *\n     * The smallest region that contains the current time. If several such\n     * regions exist, take the first. Return `null` if none exist.\n     *\n     * @returns {Region} The current region\n     */\n    getCurrentRegion() {\n        const time = this.wavesurfer.getCurrentTime();\n        let min = null;\n        Object.keys(this.list).forEach(id => {\n            const cur = this.list[id];\n            if (cur.start <= time && cur.end >= time) {\n                if (!min || cur.end - cur.start < min.end - min.start) {\n                    min = cur;\n                }\n            }\n        });\n\n        return min;\n    }\n\n    /**\n     * Match the value to the grid, if required\n     *\n     * If the regions plugin params have a snapToGridInterval set, return the\n     * value matching the nearest grid interval. If no snapToGridInterval is set,\n     * the passed value will be returned without modification.\n     *\n     * @param {number} value the value to snap to the grid, if needed\n     * @param {Object} params the regions plugin params\n     * @returns {number} value\n     */\n    getRegionSnapToGridValue(value, params) {\n        if (params.snapToGridInterval) {\n            // the regions should snap to a grid\n            const offset = params.snapToGridOffset || 0;\n            return (\n                Math.round((value - offset) / params.snapToGridInterval) *\n                    params.snapToGridInterval +\n                offset\n            );\n        }\n\n        // no snap-to-grid\n        return value;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}