{"ast":null,"code":"/**\n *  @since 4.0.0\n *\n * (Single) Region plugin class\n *\n * Must be turned into an observer before instantiating. This is done in\n * `RegionsPlugin` (main plugin class).\n *\n * @extends {Observer}\n */\nexport class Region {\n  constructor(params, regionsUtils, ws) {\n    this.wavesurfer = ws;\n    this.wrapper = ws.drawer.wrapper;\n    this.util = ws.util;\n    this.style = this.util.style;\n    this.regionsUtil = regionsUtils;\n    this.vertical = ws.drawer.params.vertical;\n    this.id = params.id == null ? ws.util.getId() : params.id;\n    this.start = Number(params.start) || 0;\n    this.end = params.end == null ? // small marker-like region\n    this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);\n    this.resize = params.resize === undefined ? true : Boolean(params.resize);\n    this.drag = params.drag === undefined ? true : Boolean(params.drag);\n    this.contentEditable = Boolean(params.contentEditable);\n    this.removeButton = Boolean(params.removeButton); // reflect resize and drag state of region for region-updated listener\n\n    this.isResizing = false;\n    this.isDragging = false;\n    this.loop = Boolean(params.loop);\n    this.color = params.color || 'rgba(0, 0, 0, 0.1)'; // The left and right handleStyle properties can be set to 'none' for\n    // no styling or can be assigned an object containing CSS properties.\n\n    this.handleStyle = params.handleStyle || {\n      left: {},\n      right: {}\n    };\n    this.handleLeftEl = null;\n    this.handleRightEl = null;\n    this.data = params.data || {};\n    this.attributes = params.attributes || {};\n    this.showTooltip = params.showTooltip ?? true;\n    this.maxLength = params.maxLength; // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided\n\n    this.minLength = params.minLength;\n\n    this._onRedraw = () => this.updateRender();\n\n    this.scroll = params.scroll !== false && ws.params.scrollParent;\n    this.scrollSpeed = params.scrollSpeed || 1;\n    this.scrollThreshold = params.scrollThreshold || 10; // Determines whether the context menu is prevented from being opened.\n\n    this.preventContextMenu = params.preventContextMenu === undefined ? false : Boolean(params.preventContextMenu); // select channel ID to set region\n\n    let channelIdx = params.channelIdx == null ? -1 : parseInt(params.channelIdx);\n    this.channelIdx = channelIdx;\n    this.regionHeight = '100%';\n    this.marginTop = '0px';\n\n    if (channelIdx !== -1) {\n      let channelCount = this.wavesurfer.backend.buffer != null ? this.wavesurfer.backend.buffer.numberOfChannels : -1;\n\n      if (channelCount >= 0 && channelIdx < channelCount) {\n        this.regionHeight = Math.floor(1 / channelCount * 100) + '%';\n        this.marginTop = this.wavesurfer.getHeight() * channelIdx + 'px';\n      }\n    }\n\n    this.formatTimeCallback = params.formatTimeCallback;\n    this.edgeScrollWidth = params.edgeScrollWidth;\n    this.bindInOut();\n    this.render();\n    this.wavesurfer.on('zoom', this._onRedraw);\n    this.wavesurfer.on('redraw', this._onRedraw);\n    this.wavesurfer.fireEvent('region-created', this);\n  }\n  /* Update region params. */\n\n\n  update(params, eventParams) {\n    if (params.start != null) {\n      this.start = Number(params.start);\n    }\n\n    if (params.end != null) {\n      this.end = Number(params.end);\n    }\n\n    if (params.loop != null) {\n      this.loop = Boolean(params.loop);\n    }\n\n    if (params.color != null) {\n      this.color = params.color;\n    }\n\n    if (params.handleStyle != null) {\n      this.handleStyle = params.handleStyle;\n    }\n\n    if (params.data != null) {\n      this.data = params.data;\n    }\n\n    if (params.resize != null) {\n      this.resize = Boolean(params.resize);\n      this.updateHandlesResize(this.resize);\n    }\n\n    if (params.drag != null) {\n      this.drag = Boolean(params.drag);\n    }\n\n    if (params.maxLength != null) {\n      this.maxLength = Number(params.maxLength);\n    }\n\n    if (params.minLength != null) {\n      this.minLength = Number(params.minLength);\n    }\n\n    if (params.attributes != null) {\n      this.attributes = params.attributes;\n    }\n\n    this.updateRender();\n    this.fireEvent('update');\n    this.wavesurfer.fireEvent('region-updated', this, eventParams);\n  }\n  /* Remove a single region. */\n\n\n  remove() {\n    if (this.element) {\n      this.element.remove();\n      this.element = null;\n      this.fireEvent('remove');\n      this.wavesurfer.un('zoom', this._onRedraw);\n      this.wavesurfer.un('redraw', this._onRedraw);\n      this.wavesurfer.fireEvent('region-removed', this);\n    }\n  }\n  /**\n   * Play the audio region.\n   * @param {number} start Optional offset to start playing at\n   */\n\n\n  play(start) {\n    const s = start || this.start;\n    this.wavesurfer.play(s, this.end);\n    this.fireEvent('play');\n    this.wavesurfer.fireEvent('region-play', this);\n  }\n  /**\n   * Play the audio region in a loop.\n   * @param {number} start Optional offset to start playing at\n   * */\n\n\n  playLoop(start) {\n    this.loop = true;\n    this.play(start);\n  }\n  /**\n   * Set looping on/off.\n   * @param {boolean} loop True if should play in loop\n   */\n\n\n  setLoop(loop) {\n    this.loop = loop;\n  }\n  /* Render a region as a DOM element. */\n\n\n  render() {\n    this.element = this.util.withOrientation(this.wrapper.appendChild(document.createElement('region')), this.vertical);\n    this.element.className = 'wavesurfer-region';\n\n    if (this.showTooltip) {\n      this.element.title = this.formatTime(this.start, this.end);\n    }\n\n    this.element.setAttribute('data-id', this.id);\n\n    for (const attrname in this.attributes) {\n      this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n    }\n\n    this.style(this.element, {\n      position: 'absolute',\n      zIndex: 3,\n      height: this.regionHeight,\n      top: this.marginTop\n    });\n    /* Button Remove Region */\n\n    if (this.removeButton) {\n      const removeButtonEl = document.createElement('div');\n      removeButtonEl.className = 'remove-region-button';\n      removeButtonEl.textContent = 'тип';\n      this.removeButtonEl = this.element.appendChild(removeButtonEl);\n      const css = {\n        zIndex: 4,\n        position: 'absolute',\n        bottom: 0,\n        right: '4px',\n        cursor: 'pointer',\n        fontSize: '20px',\n        lineHeight: '21px',\n        color: 'grey'\n      };\n      this.style(this.removeButtonEl, css);\n    }\n    /* Edit content */\n\n\n    if (this.contentEditable) {\n      const contentEl = document.createElement('div');\n      contentEl.className = 'region-content';\n      contentEl.contentEditable = 'true';\n      contentEl.innerText = this.data.text || '';\n      this.contentEl = this.element.appendChild(contentEl);\n      const css = {\n        zIndex: 4,\n        padding: '2px 5px',\n        cursor: 'text'\n      };\n      this.style(this.contentEl, css);\n    }\n    /* Resize handles */\n\n\n    if (this.resize) {\n      this.handleLeftEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);\n      this.handleRightEl = this.util.withOrientation(this.element.appendChild(document.createElement('handle')), this.vertical);\n      this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';\n      this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end'; // Default CSS properties for both handles.\n\n      const css = {\n        cursor: this.vertical ? 'row-resize' : 'col-resize',\n        position: 'absolute',\n        top: '0px',\n        width: '2px',\n        height: '100%',\n        backgroundColor: 'rgba(0, 0, 0, 1)'\n      }; // Merge CSS properties per handle.\n\n      const handleLeftCss = this.handleStyle.left !== 'none' ? Object.assign({\n        left: '0px'\n      }, css, this.handleStyle.left) : null;\n      const handleRightCss = this.handleStyle.right !== 'none' ? Object.assign({\n        right: '0px'\n      }, css, this.handleStyle.right) : null;\n\n      if (handleLeftCss) {\n        this.style(this.handleLeftEl, handleLeftCss);\n      }\n\n      if (handleRightCss) {\n        this.style(this.handleRightEl, handleRightCss);\n      }\n    }\n\n    this.updateRender();\n    this.bindEvents();\n  }\n\n  formatTime(start, end) {\n    if (this.formatTimeCallback) {\n      return this.formatTimeCallback(start, end);\n    }\n\n    return (start == end ? [start] : [start, end]).map(time => [Math.floor(time % 3600 / 60), // minutes\n    ('00' + Math.floor(time % 60)).slice(-2) // seconds\n    ].join(':')).join('-');\n  }\n\n  getWidth() {\n    return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n  }\n  /* Update element's position, width, color. */\n\n\n  updateRender() {\n    // duration varies during loading process, so don't overwrite important data\n    const dur = this.wavesurfer.getDuration();\n    const width = this.getWidth();\n    let startLimited = this.start;\n    let endLimited = this.end;\n\n    if (startLimited < 0) {\n      startLimited = 0;\n      endLimited = endLimited - startLimited;\n    }\n\n    if (endLimited > dur) {\n      endLimited = dur;\n      startLimited = dur - (endLimited - startLimited);\n    }\n\n    if (this.minLength != null) {\n      endLimited = Math.max(startLimited + this.minLength, endLimited);\n    }\n\n    if (this.maxLength != null) {\n      endLimited = Math.min(startLimited + this.maxLength, endLimited);\n    }\n\n    if (this.element != null) {\n      // Calculate the left and width values of the region such that\n      // no gaps appear between regions.\n      const left = Math.round(startLimited / dur * width);\n      const regionWidth = Math.round(endLimited / dur * width) - left;\n      this.style(this.element, {\n        left: left + 'px',\n        width: regionWidth + 'px',\n        backgroundColor: this.color,\n        cursor: this.drag ? 'move' : 'default'\n      });\n\n      for (const attrname in this.attributes) {\n        this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n      }\n\n      if (this.showTooltip) {\n        this.element.title = this.formatTime(this.start, this.end);\n      }\n    }\n  }\n  /* Bind audio events. */\n\n\n  bindInOut() {\n    this.firedIn = false;\n    this.firedOut = false;\n\n    const onProcess = time => {\n      let start = Math.round(this.start * 10) / 10;\n      let end = Math.round(this.end * 10) / 10;\n      time = Math.round(time * 10) / 10;\n\n      if (!this.firedOut && this.firedIn && (start > time || end <= time)) {\n        this.firedOut = true;\n        this.firedIn = false;\n        this.fireEvent('out');\n        this.wavesurfer.fireEvent('region-out', this);\n      }\n\n      if (!this.firedIn && start <= time && end > time) {\n        this.firedIn = true;\n        this.firedOut = false;\n        this.fireEvent('in');\n        this.wavesurfer.fireEvent('region-in', this);\n      }\n    };\n\n    this.wavesurfer.backend.on('audioprocess', onProcess);\n    this.on('remove', () => {\n      this.wavesurfer.backend.un('audioprocess', onProcess);\n    });\n    /* Loop playback. */\n\n    this.on('out', () => {\n      if (this.loop) {\n        const realTime = this.wavesurfer.getCurrentTime();\n\n        if (realTime >= this.start && realTime <= this.end) {\n          this.wavesurfer.play(this.start);\n        }\n      }\n    });\n  }\n  /* Bind DOM events. */\n\n\n  bindEvents() {\n    const preventContextMenu = this.preventContextMenu;\n    this.element.addEventListener('mouseenter', e => {\n      this.fireEvent('mouseenter', e);\n      this.wavesurfer.fireEvent('region-mouseenter', this, e);\n    });\n    this.element.addEventListener('mouseleave', e => {\n      this.fireEvent('mouseleave', e);\n      this.wavesurfer.fireEvent('region-mouseleave', this, e);\n    });\n    this.element.addEventListener('click', e => {\n      e.preventDefault();\n      this.fireEvent('click', e);\n      this.wavesurfer.fireEvent('region-click', this, e);\n    });\n    this.element.addEventListener('dblclick', e => {\n      e.stopPropagation();\n      e.preventDefault();\n      this.fireEvent('dblclick', e);\n      this.wavesurfer.fireEvent('region-dblclick', this, e);\n    });\n    this.element.addEventListener('contextmenu', e => {\n      if (preventContextMenu) {\n        e.preventDefault();\n      }\n\n      this.fireEvent('contextmenu', e);\n      this.wavesurfer.fireEvent('region-contextmenu', this, e);\n    });\n    /* Drag or resize on mousemove. */\n\n    if (this.drag || this.resize) {\n      this.bindDragEvents();\n    }\n    /* Edit content */\n\n\n    if (this.contentEditable) {\n      this.contentEl.addEventListener('blur', this.onContentBlur.bind(this));\n      this.contentEl.addEventListener('click', this.onContentClick.bind(this));\n    }\n    /* Remove button */\n\n\n    if (this.removeButton) {\n      this.removeButtonEl.addEventListener('click', this.onRemove.bind(this));\n    }\n  }\n\n  bindDragEvents() {\n    const container = this.wavesurfer.drawer.container;\n    const scrollSpeed = this.scrollSpeed;\n    let startTime;\n    let touchId;\n    let drag;\n    let maxScroll;\n    let resize;\n    let updated = false;\n    let scrollDirection;\n    let wrapperRect;\n    let regionLeftHalfTime;\n    let regionRightHalfTime; // Scroll when the user is dragging within the threshold\n\n    const edgeScroll = event => {\n      let orientedEvent = this.util.withOrientation(event, this.vertical);\n      const duration = this.wavesurfer.getDuration();\n\n      if (!scrollDirection || !drag && !resize) {\n        return;\n      }\n\n      const x = orientedEvent.clientX;\n      let distanceBetweenCursorAndWrapperEdge = 0;\n      let regionHalfTimeWidth = 0;\n      let adjustment = 0; // Get the currently selected time according to the mouse position\n\n      let time = this.regionsUtil.getRegionSnapToGridValue(this.wavesurfer.drawer.handleEvent(event) * duration);\n\n      if (drag) {\n        // Considering the point of contact with the region while edgescrolling\n        if (scrollDirection === -1) {\n          regionHalfTimeWidth = regionLeftHalfTime * this.wavesurfer.params.minPxPerSec;\n          distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;\n        } else {\n          regionHalfTimeWidth = regionRightHalfTime * this.wavesurfer.params.minPxPerSec;\n          distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;\n        }\n      } else {\n        // Considering minLength while edgescroll\n        let minLength = this.minLength;\n\n        if (!minLength) {\n          minLength = 0;\n        }\n\n        if (resize === 'start') {\n          if (time > this.end - minLength) {\n            time = this.end - minLength;\n            adjustment = scrollSpeed * scrollDirection;\n          }\n\n          if (time < 0) {\n            time = 0;\n          }\n        } else if (resize === 'end') {\n          if (time < this.start + minLength) {\n            time = this.start + minLength;\n            adjustment = scrollSpeed * scrollDirection;\n          }\n\n          if (time > duration) {\n            time = duration;\n          }\n        }\n      } // Don't edgescroll if region has reached min or max limit\n\n\n      const wrapperScrollLeft = this.wrapper.scrollLeft;\n\n      if (scrollDirection === -1) {\n        if (Math.round(wrapperScrollLeft) === 0) {\n          return;\n        }\n\n        if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {\n          return;\n        }\n      } else {\n        if (Math.round(wrapperScrollLeft) === maxScroll) {\n          return;\n        }\n\n        if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {\n          return;\n        }\n      } // Update scroll position\n\n\n      let scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;\n\n      if (scrollDirection === -1) {\n        const calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);\n        this.wrapper.scrollLeft = scrollLeft = calculatedLeft;\n      } else {\n        const calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);\n        this.wrapper.scrollLeft = scrollLeft = calculatedRight;\n      }\n\n      const delta = time - startTime;\n      startTime = time; // Continue dragging or resizing\n\n      drag ? this.onDrag(delta) : this.onResize(delta, resize); // Repeat\n\n      window.requestAnimationFrame(() => {\n        edgeScroll(event);\n      });\n    };\n\n    const onDown = event => {\n      const duration = this.wavesurfer.getDuration();\n\n      if (event.touches && event.touches.length > 1) {\n        return;\n      }\n\n      touchId = event.targetTouches ? event.targetTouches[0].identifier : null; // stop the event propagation, if this region is resizable or draggable\n      // and the event is therefore handled here.\n\n      if (this.drag || this.resize) {\n        event.stopPropagation();\n      } // Store the selected startTime we begun dragging or resizing\n\n\n      startTime = this.regionsUtil.getRegionSnapToGridValue(this.wavesurfer.drawer.handleEvent(event, true) * duration); // Store the selected point of contact when we begin dragging\n\n      regionLeftHalfTime = startTime - this.start;\n      regionRightHalfTime = this.end - startTime; // Store for scroll calculations\n\n      maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n      wrapperRect = this.util.withOrientation(this.wrapper.getBoundingClientRect(), this.vertical);\n      this.isResizing = false;\n      this.isDragging = false;\n\n      if (event.target.tagName.toLowerCase() === 'handle') {\n        this.isResizing = true;\n        resize = event.target.classList.contains('wavesurfer-handle-start') ? 'start' : 'end';\n      } else {\n        this.isDragging = true;\n        drag = true;\n        resize = false;\n      }\n    };\n\n    const onUp = event => {\n      if (event.touches && event.touches.length > 1) {\n        return;\n      }\n\n      if (drag || resize) {\n        this.isDragging = false;\n        this.isResizing = false;\n        drag = false;\n        scrollDirection = null;\n        resize = false;\n      }\n\n      if (updated) {\n        updated = false;\n        this.util.preventClick();\n        this.fireEvent('update-end', event);\n        this.wavesurfer.fireEvent('region-update-end', this, event);\n      }\n    };\n\n    const onMove = event => {\n      const duration = this.wavesurfer.getDuration();\n      let orientedEvent = this.util.withOrientation(event, this.vertical);\n      let delta = null;\n\n      if (event.touches && event.touches.length > 1) {\n        return;\n      }\n\n      if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n        return;\n      }\n\n      if (!drag && !resize) {\n        return;\n      }\n\n      const oldTime = startTime;\n      let time = this.regionsUtil.getRegionSnapToGridValue(this.wavesurfer.drawer.handleEvent(event) * duration);\n\n      if (drag) {\n        // To maintain relative cursor start point while dragging\n        const maxEnd = this.wavesurfer.getDuration();\n\n        if (time > maxEnd - regionRightHalfTime) {\n          time = maxEnd - regionRightHalfTime;\n        }\n\n        if (time - regionLeftHalfTime < 0) {\n          time = regionLeftHalfTime;\n        }\n      }\n\n      if (resize) {\n        // To maintain relative cursor start point while resizing\n        // we have to handle for minLength\n        let minLength = this.minLength;\n\n        if (!minLength) {\n          minLength = 0;\n        }\n\n        if (resize === 'start') {\n          if (time > this.end - minLength) {\n            time = this.end - minLength;\n          }\n\n          if (time < 0) {\n            time = 0;\n          }\n        } else if (resize === 'end') {\n          if (time < this.start + minLength) {\n            // Calculate the end time based on the min length of the region.\n            time = this.start + minLength;\n            delta = time - (this.end + (time - startTime));\n          }\n\n          if (time > duration) {\n            time = duration;\n          }\n        }\n      }\n\n      if (!delta) {\n        delta = time - startTime;\n      }\n\n      startTime = time; // Drag\n\n      if (this.drag && drag) {\n        updated = updated || !!delta;\n        this.onDrag(delta);\n      } // Resize\n\n\n      if (this.resize && resize) {\n        updated = updated || !!delta;\n        this.onResize(delta, resize);\n      }\n\n      if (this.scroll && container.clientWidth < this.wrapper.scrollWidth) {\n        // Triggering edgescroll from within edgeScrollWidth\n        let x = orientedEvent.clientX; // Check direction\n\n        if (x < wrapperRect.left + this.edgeScrollWidth) {\n          scrollDirection = -1;\n        } else if (x > wrapperRect.right - this.edgeScrollWidth) {\n          scrollDirection = 1;\n        } else {\n          scrollDirection = null;\n        }\n\n        if (scrollDirection) {\n          edgeScroll(event);\n        }\n      }\n    };\n\n    this.element.addEventListener('mousedown', onDown);\n    this.element.addEventListener('touchstart', onDown);\n    document.body.addEventListener('mousemove', onMove);\n    document.body.addEventListener('touchmove', onMove, {\n      passive: false\n    });\n    document.addEventListener('mouseup', onUp);\n    document.body.addEventListener('touchend', onUp);\n    this.on('remove', () => {\n      document.removeEventListener('mouseup', onUp);\n      document.body.removeEventListener('touchend', onUp);\n      document.body.removeEventListener('mousemove', onMove);\n      document.body.removeEventListener('touchmove', onMove);\n    });\n    this.wavesurfer.on('destroy', () => {\n      document.removeEventListener('mouseup', onUp);\n      document.body.removeEventListener('touchend', onUp);\n    });\n  }\n\n  onDrag(delta) {\n    const maxEnd = this.wavesurfer.getDuration();\n\n    if (this.end + delta > maxEnd) {\n      delta = maxEnd - this.end;\n    }\n\n    if (this.start + delta < 0) {\n      delta = this.start * -1;\n    }\n\n    const eventParams = {\n      direction: this._getDragDirection(delta),\n      action: 'drag'\n    };\n    this.update({\n      start: this.start + delta,\n      end: this.end + delta\n    }, eventParams);\n  }\n  /**\n   * Returns the direction of dragging region based on delta\n   * Negative delta means region is moving to the left\n   * Positive - to the right\n   * For zero delta the direction is not defined\n   * @param {number} delta Drag offset\n   * @returns {string|null} Direction 'left', 'right' or null\n   */\n\n\n  _getDragDirection(delta) {\n    if (delta < 0) {\n      return 'left';\n    }\n\n    if (delta > 0) {\n      return 'right';\n    }\n\n    return null;\n  }\n  /**\n   * @example\n   * onResize(-5, 'start') // Moves the start point 5 seconds back\n   * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward\n   *\n   * @param {number} delta How much to add or subtract, given in seconds\n   * @param {string} direction 'start 'or 'end'\n   */\n\n\n  onResize(delta, direction) {\n    const duration = this.wavesurfer.getDuration();\n    const eventParams = {\n      action: 'resize',\n      direction: direction === 'start' ? 'left' : 'right'\n    };\n\n    if (direction === 'start') {\n      // Check if changing the start by the given delta would result in the region being smaller than minLength\n      if (delta > 0 && this.end - (this.start + delta) < this.minLength) {\n        delta = this.end - this.minLength - this.start;\n      } // Check if changing the start by the given delta would result in the region being larger than maxLength\n\n\n      if (delta < 0 && this.end - (this.start + delta) > this.maxLength) {\n        delta = this.end - this.start - this.maxLength;\n      }\n\n      if (delta < 0 && this.start + delta < 0) {\n        delta = this.start * -1;\n      }\n\n      this.update({\n        start: Math.min(this.start + delta, this.end),\n        end: Math.max(this.start + delta, this.end)\n      }, eventParams);\n    } else {\n      // Check if changing the end by the given delta would result in the region being smaller than minLength\n      if (delta < 0 && this.end + delta - this.start < this.minLength) {\n        delta = this.start + this.minLength - this.end;\n      } // Check if changing the end by the given delta would result in the region being larger than maxLength\n\n\n      if (delta > 0 && this.end + delta - this.start > this.maxLength) {\n        delta = this.maxLength - (this.end - this.start);\n      }\n\n      if (delta > 0 && this.end + delta > duration) {\n        delta = duration - this.end;\n      }\n\n      this.update({\n        start: Math.min(this.end + delta, this.start),\n        end: Math.max(this.end + delta, this.start)\n      }, eventParams);\n    }\n  }\n\n  onContentBlur(event) {\n    const {\n      text: oldText\n    } = this.data || {};\n    const text = event.target.innerText;\n    const data = { ...this.data,\n      text\n    };\n    const eventParams = {\n      action: 'contentEdited',\n      oldText,\n      text\n    };\n    this.update({\n      data\n    }, eventParams);\n  }\n\n  onContentClick(event) {\n    event.stopPropagation();\n  }\n\n  onRemove(event) {\n    event.stopPropagation();\n    this.remove();\n  }\n\n  updateHandlesResize(resize) {\n    let cursorStyle;\n\n    if (resize) {\n      cursorStyle = this.vertical ? 'row-resize' : 'col-resize';\n    } else {\n      cursorStyle = 'auto';\n    }\n\n    this.handleLeftEl && this.style(this.handleLeftEl, {\n      cursor: cursorStyle\n    });\n    this.handleRightEl && this.style(this.handleRightEl, {\n      cursor: cursorStyle\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/niteshsingh/Desktop/Voimo/frontend/node_modules/wavesurfer.js/src/plugin/regions/region.js"],"names":["Region","constructor","params","regionsUtils","ws","wavesurfer","wrapper","drawer","util","style","regionsUtil","vertical","id","getId","start","Number","end","scrollWidth","getDuration","resize","undefined","Boolean","drag","contentEditable","removeButton","isResizing","isDragging","loop","color","handleStyle","left","right","handleLeftEl","handleRightEl","data","attributes","showTooltip","maxLength","minLength","_onRedraw","updateRender","scroll","scrollParent","scrollSpeed","scrollThreshold","preventContextMenu","channelIdx","parseInt","regionHeight","marginTop","channelCount","backend","buffer","numberOfChannels","Math","floor","getHeight","formatTimeCallback","edgeScrollWidth","bindInOut","render","on","fireEvent","update","eventParams","updateHandlesResize","remove","element","un","play","s","playLoop","setLoop","withOrientation","appendChild","document","createElement","className","title","formatTime","setAttribute","attrname","position","zIndex","height","top","removeButtonEl","textContent","css","bottom","cursor","fontSize","lineHeight","contentEl","innerText","text","padding","width","backgroundColor","handleLeftCss","Object","assign","handleRightCss","bindEvents","map","time","slice","join","getWidth","pixelRatio","dur","startLimited","endLimited","max","min","round","regionWidth","firedIn","firedOut","onProcess","realTime","getCurrentTime","addEventListener","e","preventDefault","stopPropagation","bindDragEvents","onContentBlur","bind","onContentClick","onRemove","container","startTime","touchId","maxScroll","updated","scrollDirection","wrapperRect","regionLeftHalfTime","regionRightHalfTime","edgeScroll","event","orientedEvent","duration","x","clientX","distanceBetweenCursorAndWrapperEdge","regionHalfTimeWidth","adjustment","getRegionSnapToGridValue","handleEvent","minPxPerSec","wrapperScrollLeft","scrollLeft","calculatedLeft","calculatedRight","delta","onDrag","onResize","window","requestAnimationFrame","onDown","touches","length","targetTouches","identifier","clientWidth","getBoundingClientRect","target","tagName","toLowerCase","classList","contains","onUp","preventClick","onMove","oldTime","maxEnd","body","passive","removeEventListener","direction","_getDragDirection","action","oldText","cursorStyle"],"mappings":"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","sourcesContent":["/**\n *  @since 4.0.0\n *\n * (Single) Region plugin class\n *\n * Must be turned into an observer before instantiating. This is done in\n * `RegionsPlugin` (main plugin class).\n *\n * @extends {Observer}\n */\nexport class Region {\n    constructor(params, regionsUtils, ws) {\n        this.wavesurfer = ws;\n        this.wrapper = ws.drawer.wrapper;\n        this.util = ws.util;\n        this.style = this.util.style;\n        this.regionsUtil = regionsUtils;\n        this.vertical = ws.drawer.params.vertical;\n\n        this.id = params.id == null ? ws.util.getId() : params.id;\n        this.start = Number(params.start) || 0;\n        this.end =\n            params.end == null\n                ? // small marker-like region\n                this.start +\n                (4 / this.wrapper.scrollWidth) * this.wavesurfer.getDuration()\n                : Number(params.end);\n        this.resize =\n            params.resize === undefined ? true : Boolean(params.resize);\n        this.drag = params.drag === undefined ? true : Boolean(params.drag);\n        this.contentEditable = Boolean(params.contentEditable);\n        this.removeButton = Boolean(params.removeButton);\n        // reflect resize and drag state of region for region-updated listener\n        this.isResizing = false;\n        this.isDragging = false;\n        this.loop = Boolean(params.loop);\n        this.color = params.color || 'rgba(0, 0, 0, 0.1)';\n        // The left and right handleStyle properties can be set to 'none' for\n        // no styling or can be assigned an object containing CSS properties.\n        this.handleStyle = params.handleStyle || {\n            left: {},\n            right: {}\n        };\n        this.handleLeftEl = null;\n        this.handleRightEl = null;\n        this.data = params.data || {};\n        this.attributes = params.attributes || {};\n        this.showTooltip = params.showTooltip ?? true;\n\n        this.maxLength = params.maxLength;\n        // It assumes the minLength parameter value, or the regionsMinLength parameter value, if the first one not provided\n        this.minLength = params.minLength;\n        this._onRedraw = () => this.updateRender();\n\n        this.scroll = params.scroll !== false && ws.params.scrollParent;\n        this.scrollSpeed = params.scrollSpeed || 1;\n        this.scrollThreshold = params.scrollThreshold || 10;\n        // Determines whether the context menu is prevented from being opened.\n        this.preventContextMenu =\n            params.preventContextMenu === undefined\n                ? false\n                : Boolean(params.preventContextMenu);\n\n        // select channel ID to set region\n        let channelIdx =\n            params.channelIdx == null ? -1 : parseInt(params.channelIdx);\n        this.channelIdx = channelIdx;\n        this.regionHeight = '100%';\n        this.marginTop = '0px';\n\n        if (channelIdx !== -1) {\n            let channelCount =\n                this.wavesurfer.backend.buffer != null\n                    ? this.wavesurfer.backend.buffer.numberOfChannels\n                    : -1;\n            if (channelCount >= 0 && channelIdx < channelCount) {\n                this.regionHeight = Math.floor((1 / channelCount) * 100) + '%';\n                this.marginTop =\n                    this.wavesurfer.getHeight() * channelIdx + 'px';\n            }\n        }\n\n        this.formatTimeCallback = params.formatTimeCallback;\n        this.edgeScrollWidth = params.edgeScrollWidth;\n        this.bindInOut();\n        this.render();\n        this.wavesurfer.on('zoom', this._onRedraw);\n        this.wavesurfer.on('redraw', this._onRedraw);\n        this.wavesurfer.fireEvent('region-created', this);\n    }\n\n    /* Update region params. */\n    update(params, eventParams) {\n        if (params.start != null) {\n            this.start = Number(params.start);\n        }\n        if (params.end != null) {\n            this.end = Number(params.end);\n        }\n        if (params.loop != null) {\n            this.loop = Boolean(params.loop);\n        }\n        if (params.color != null) {\n            this.color = params.color;\n        }\n        if (params.handleStyle != null) {\n            this.handleStyle = params.handleStyle;\n        }\n        if (params.data != null) {\n            this.data = params.data;\n        }\n        if (params.resize != null) {\n            this.resize = Boolean(params.resize);\n            this.updateHandlesResize(this.resize);\n        }\n        if (params.drag != null) {\n            this.drag = Boolean(params.drag);\n        }\n        if (params.maxLength != null) {\n            this.maxLength = Number(params.maxLength);\n        }\n        if (params.minLength != null) {\n            this.minLength = Number(params.minLength);\n        }\n        if (params.attributes != null) {\n            this.attributes = params.attributes;\n        }\n\n        this.updateRender();\n        this.fireEvent('update');\n        this.wavesurfer.fireEvent('region-updated', this, eventParams);\n    }\n\n    /* Remove a single region. */\n    remove() {\n        if (this.element) {\n            this.element.remove();\n            this.element = null;\n            this.fireEvent('remove');\n            this.wavesurfer.un('zoom', this._onRedraw);\n            this.wavesurfer.un('redraw', this._onRedraw);\n            this.wavesurfer.fireEvent('region-removed', this);\n        }\n    }\n\n    /**\n     * Play the audio region.\n     * @param {number} start Optional offset to start playing at\n     */\n    play(start) {\n        const s = start || this.start;\n        this.wavesurfer.play(s, this.end);\n        this.fireEvent('play');\n        this.wavesurfer.fireEvent('region-play', this);\n    }\n\n    /**\n     * Play the audio region in a loop.\n     * @param {number} start Optional offset to start playing at\n     * */\n    playLoop(start) {\n        this.loop = true;\n        this.play(start);\n    }\n\n    /**\n     * Set looping on/off.\n     * @param {boolean} loop True if should play in loop\n     */\n    setLoop(loop) {\n        this.loop = loop;\n    }\n\n    /* Render a region as a DOM element. */\n    render() {\n        this.element = this.util.withOrientation(\n            this.wrapper.appendChild(document.createElement('region')),\n            this.vertical\n        );\n\n        this.element.className = 'wavesurfer-region';\n        if (this.showTooltip) {\n            this.element.title = this.formatTime(this.start, this.end);\n        }\n        this.element.setAttribute('data-id', this.id);\n\n        for (const attrname in this.attributes) {\n            this.element.setAttribute(\n                'data-region-' + attrname,\n                this.attributes[attrname]\n            );\n        }\n\n        this.style(this.element, {\n            position: 'absolute',\n            zIndex: 3,\n            height: this.regionHeight,\n            top: this.marginTop\n        });\n\n        /* Button Remove Region */\n        if (this.removeButton){\n            const removeButtonEl = document.createElement('div');\n            removeButtonEl.className = 'remove-region-button';\n            removeButtonEl.textContent = 'тип';\n            this.removeButtonEl = this.element.appendChild(removeButtonEl);\n            const css = {\n                zIndex: 4,\n                position: 'absolute',\n                bottom: 0,\n                right: '4px',\n                cursor:'pointer',\n                fontSize: '20px',\n                lineHeight: '21px',\n                color: 'grey'\n            };\n            this.style(this.removeButtonEl, css);\n        }\n\n        /* Edit content */\n        if (this.contentEditable){\n            const contentEl = document.createElement('div');\n            contentEl.className = 'region-content';\n            contentEl.contentEditable = 'true';\n            contentEl.innerText = this.data.text || '';\n            this.contentEl = this.element.appendChild(contentEl);\n            const css = {\n                zIndex: 4,\n                padding: '2px 5px',\n                cursor:'text'};\n            this.style(this.contentEl, css);\n        }\n\n        /* Resize handles */\n        if (this.resize) {\n            this.handleLeftEl = this.util.withOrientation(\n                this.element.appendChild(document.createElement('handle')),\n                this.vertical\n            );\n            this.handleRightEl = this.util.withOrientation(\n                this.element.appendChild(document.createElement('handle')),\n                this.vertical\n            );\n\n            this.handleLeftEl.className = 'wavesurfer-handle wavesurfer-handle-start';\n            this.handleRightEl.className = 'wavesurfer-handle wavesurfer-handle-end';\n\n            // Default CSS properties for both handles.\n            const css = {\n                cursor: this.vertical ? 'row-resize' : 'col-resize',\n                position: 'absolute',\n                top: '0px',\n                width: '2px',\n                height: '100%',\n                backgroundColor: 'rgba(0, 0, 0, 1)'\n            };\n\n            // Merge CSS properties per handle.\n            const handleLeftCss =\n                this.handleStyle.left !== 'none'\n                    ? Object.assign(\n                        { left: '0px' },\n                        css,\n                        this.handleStyle.left\n                    )\n                    : null;\n            const handleRightCss =\n                this.handleStyle.right !== 'none'\n                    ? Object.assign(\n                        { right: '0px' },\n                        css,\n                        this.handleStyle.right\n                    )\n                    : null;\n\n            if (handleLeftCss) {\n                this.style(this.handleLeftEl, handleLeftCss);\n            }\n\n            if (handleRightCss) {\n                this.style(this.handleRightEl, handleRightCss);\n            }\n        }\n\n        this.updateRender();\n        this.bindEvents();\n    }\n\n    formatTime(start, end) {\n        if (this.formatTimeCallback) {\n            return this.formatTimeCallback(start, end);\n        }\n        return (start == end ? [start] : [start, end])\n            .map((time) =>\n                [\n                    Math.floor((time % 3600) / 60), // minutes\n                    ('00' + Math.floor(time % 60)).slice(-2) // seconds\n                ].join(':')\n            )\n            .join('-');\n    }\n\n    getWidth() {\n        return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n    }\n\n    /* Update element's position, width, color. */\n    updateRender() {\n        // duration varies during loading process, so don't overwrite important data\n        const dur = this.wavesurfer.getDuration();\n        const width = this.getWidth();\n\n        let startLimited = this.start;\n        let endLimited = this.end;\n        if (startLimited < 0) {\n            startLimited = 0;\n            endLimited = endLimited - startLimited;\n        }\n        if (endLimited > dur) {\n            endLimited = dur;\n            startLimited = dur - (endLimited - startLimited);\n        }\n\n        if (this.minLength != null) {\n            endLimited = Math.max(startLimited + this.minLength, endLimited);\n        }\n\n        if (this.maxLength != null) {\n            endLimited = Math.min(startLimited + this.maxLength, endLimited);\n        }\n\n        if (this.element != null) {\n            // Calculate the left and width values of the region such that\n            // no gaps appear between regions.\n            const left = Math.round((startLimited / dur) * width);\n            const regionWidth = Math.round((endLimited / dur) * width) - left;\n\n            this.style(this.element, {\n                left: left + 'px',\n                width: regionWidth + 'px',\n                backgroundColor: this.color,\n                cursor: this.drag ? 'move' : 'default'\n            });\n\n            for (const attrname in this.attributes) {\n                this.element.setAttribute(\n                    'data-region-' + attrname,\n                    this.attributes[attrname]\n                );\n            }\n\n            if (this.showTooltip) {\n                this.element.title = this.formatTime(this.start, this.end);\n            }\n        }\n    }\n\n    /* Bind audio events. */\n    bindInOut() {\n        this.firedIn = false;\n        this.firedOut = false;\n\n        const onProcess = (time) => {\n            let start = Math.round(this.start * 10) / 10;\n            let end = Math.round(this.end * 10) / 10;\n            time = Math.round(time * 10) / 10;\n\n            if (\n                !this.firedOut &&\n                this.firedIn &&\n                (start > time || end <= time)\n            ) {\n                this.firedOut = true;\n                this.firedIn = false;\n                this.fireEvent('out');\n                this.wavesurfer.fireEvent('region-out', this);\n            }\n            if (!this.firedIn && start <= time && end > time) {\n                this.firedIn = true;\n                this.firedOut = false;\n                this.fireEvent('in');\n                this.wavesurfer.fireEvent('region-in', this);\n            }\n        };\n\n        this.wavesurfer.backend.on('audioprocess', onProcess);\n\n        this.on('remove', () => {\n            this.wavesurfer.backend.un('audioprocess', onProcess);\n        });\n\n        /* Loop playback. */\n        this.on('out', () => {\n            if (this.loop) {\n                const realTime = this.wavesurfer.getCurrentTime();\n                if (realTime >= this.start && realTime <= this.end) {\n                    this.wavesurfer.play(this.start);\n                }\n            }\n        });\n    }\n\n    /* Bind DOM events. */\n    bindEvents() {\n        const preventContextMenu = this.preventContextMenu;\n\n        this.element.addEventListener('mouseenter', (e) => {\n            this.fireEvent('mouseenter', e);\n            this.wavesurfer.fireEvent('region-mouseenter', this, e);\n        });\n\n        this.element.addEventListener('mouseleave', (e) => {\n            this.fireEvent('mouseleave', e);\n            this.wavesurfer.fireEvent('region-mouseleave', this, e);\n        });\n\n        this.element.addEventListener('click', (e) => {\n            e.preventDefault();\n            this.fireEvent('click', e);\n            this.wavesurfer.fireEvent('region-click', this, e);\n        });\n\n        this.element.addEventListener('dblclick', (e) => {\n            e.stopPropagation();\n            e.preventDefault();\n            this.fireEvent('dblclick', e);\n            this.wavesurfer.fireEvent('region-dblclick', this, e);\n        });\n\n        this.element.addEventListener('contextmenu', (e) => {\n            if (preventContextMenu) {\n                e.preventDefault();\n            }\n            this.fireEvent('contextmenu', e);\n            this.wavesurfer.fireEvent('region-contextmenu', this, e);\n        });\n\n        /* Drag or resize on mousemove. */\n        if (this.drag || this.resize) {\n            this.bindDragEvents();\n        }\n\n        /* Edit content */\n        if (this.contentEditable){\n            this.contentEl.addEventListener('blur', this.onContentBlur.bind(this));\n            this.contentEl.addEventListener('click', this.onContentClick.bind(this));\n        }\n        /* Remove button */\n        if (this.removeButton){\n            this.removeButtonEl.addEventListener('click', this.onRemove.bind(this));\n        }\n    }\n\n    bindDragEvents() {\n        const container = this.wavesurfer.drawer.container;\n        const scrollSpeed = this.scrollSpeed;\n        let startTime;\n        let touchId;\n        let drag;\n        let maxScroll;\n        let resize;\n        let updated = false;\n        let scrollDirection;\n        let wrapperRect;\n        let regionLeftHalfTime;\n        let regionRightHalfTime;\n\n        // Scroll when the user is dragging within the threshold\n        const edgeScroll = (event) => {\n            let orientedEvent = this.util.withOrientation(event, this.vertical);\n            const duration = this.wavesurfer.getDuration();\n            if (!scrollDirection || (!drag && !resize)) {\n                return;\n            }\n\n            const x = orientedEvent.clientX;\n            let distanceBetweenCursorAndWrapperEdge = 0;\n            let regionHalfTimeWidth = 0;\n            let adjustment = 0;\n\n            // Get the currently selected time according to the mouse position\n            let time = this.regionsUtil.getRegionSnapToGridValue(\n                this.wavesurfer.drawer.handleEvent(event) * duration\n            );\n\n            if (drag) {\n                // Considering the point of contact with the region while edgescrolling\n                if (scrollDirection === -1) {\n                    regionHalfTimeWidth = regionLeftHalfTime * this.wavesurfer.params.minPxPerSec;\n                    distanceBetweenCursorAndWrapperEdge = x - wrapperRect.left;\n                } else {\n                    regionHalfTimeWidth = regionRightHalfTime * this.wavesurfer.params.minPxPerSec;\n                    distanceBetweenCursorAndWrapperEdge = wrapperRect.right - x;\n                }\n            } else {\n                // Considering minLength while edgescroll\n                let minLength = this.minLength;\n                if (!minLength) {\n                    minLength = 0;\n                }\n\n                if (resize === 'start') {\n                    if (time > this.end - minLength) {\n                        time = this.end - minLength;\n                        adjustment = scrollSpeed * scrollDirection;\n                    }\n\n                    if (time < 0) {\n                        time = 0;\n                    }\n                } else if (resize === 'end') {\n                    if (time < this.start + minLength) {\n                        time = this.start + minLength;\n                        adjustment = scrollSpeed * scrollDirection;\n                    }\n\n                    if (time > duration) {\n                        time = duration;\n                    }\n                }\n            }\n\n            // Don't edgescroll if region has reached min or max limit\n            const wrapperScrollLeft = this.wrapper.scrollLeft;\n\n            if (scrollDirection === -1) {\n                if (Math.round(wrapperScrollLeft) === 0) {\n                    return;\n                }\n\n                if (Math.round(wrapperScrollLeft - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge) <= 0) {\n                    return;\n                }\n            } else {\n                if (Math.round(wrapperScrollLeft) === maxScroll) {\n                    return;\n                }\n\n                if (Math.round(wrapperScrollLeft + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge) >= maxScroll) {\n                    return;\n                }\n            }\n\n            // Update scroll position\n            let scrollLeft = wrapperScrollLeft - adjustment + scrollSpeed * scrollDirection;\n\n            if (scrollDirection === -1) {\n                const calculatedLeft = Math.max(0 + regionHalfTimeWidth - distanceBetweenCursorAndWrapperEdge, scrollLeft);\n                this.wrapper.scrollLeft = scrollLeft = calculatedLeft;\n            } else {\n                const calculatedRight = Math.min(maxScroll - regionHalfTimeWidth + distanceBetweenCursorAndWrapperEdge, scrollLeft);\n                this.wrapper.scrollLeft = scrollLeft = calculatedRight;\n            }\n\n            const delta = time - startTime;\n            startTime = time;\n\n            // Continue dragging or resizing\n            drag ? this.onDrag(delta) : this.onResize(delta, resize);\n\n            // Repeat\n            window.requestAnimationFrame(() => {\n                edgeScroll(event);\n            });\n        };\n\n        const onDown = (event) => {\n            const duration = this.wavesurfer.getDuration();\n            if (event.touches && event.touches.length > 1) {\n                return;\n            }\n            touchId = event.targetTouches ? event.targetTouches[0].identifier : null;\n\n            // stop the event propagation, if this region is resizable or draggable\n            // and the event is therefore handled here.\n            if (this.drag || this.resize) {\n                event.stopPropagation();\n            }\n\n            // Store the selected startTime we begun dragging or resizing\n            startTime = this.regionsUtil.getRegionSnapToGridValue(\n                this.wavesurfer.drawer.handleEvent(event, true) * duration\n            );\n\n            // Store the selected point of contact when we begin dragging\n            regionLeftHalfTime = startTime - this.start;\n            regionRightHalfTime = this.end - startTime;\n\n            // Store for scroll calculations\n            maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n\n            wrapperRect = this.util.withOrientation(\n                this.wrapper.getBoundingClientRect(),\n                this.vertical\n            );\n\n            this.isResizing = false;\n            this.isDragging = false;\n            if (event.target.tagName.toLowerCase() === 'handle') {\n                this.isResizing = true;\n                resize = event.target.classList.contains('wavesurfer-handle-start')\n                    ? 'start'\n                    : 'end';\n            } else {\n                this.isDragging = true;\n                drag = true;\n                resize = false;\n            }\n        };\n        const onUp = (event) => {\n            if (event.touches && event.touches.length > 1) {\n                return;\n            }\n\n            if (drag || resize) {\n                this.isDragging = false;\n                this.isResizing = false;\n                drag = false;\n                scrollDirection = null;\n                resize = false;\n            }\n\n            if (updated) {\n                updated = false;\n                this.util.preventClick();\n                this.fireEvent('update-end', event);\n                this.wavesurfer.fireEvent('region-update-end', this, event);\n            }\n        };\n        const onMove = (event) => {\n            const duration = this.wavesurfer.getDuration();\n            let orientedEvent = this.util.withOrientation(event, this.vertical);\n            let delta = null;\n\n            if (event.touches && event.touches.length > 1) {\n                return;\n            }\n            if (event.targetTouches && event.targetTouches[0].identifier != touchId) {\n                return;\n            }\n            if (!drag && !resize) {\n                return;\n            }\n\n            const oldTime = startTime;\n            let time = this.regionsUtil.getRegionSnapToGridValue(\n                this.wavesurfer.drawer.handleEvent(event) * duration\n            );\n\n            if (drag) {\n                // To maintain relative cursor start point while dragging\n                const maxEnd = this.wavesurfer.getDuration();\n                if (time > maxEnd - regionRightHalfTime) {\n                    time = maxEnd - regionRightHalfTime;\n                }\n\n                if (time - regionLeftHalfTime < 0) {\n                    time = regionLeftHalfTime;\n                }\n            }\n\n            if (resize) {\n                // To maintain relative cursor start point while resizing\n                // we have to handle for minLength\n                let minLength = this.minLength;\n                if (!minLength) {\n                    minLength = 0;\n                }\n\n                if (resize === 'start') {\n                    if (time > this.end - minLength) {\n                        time = this.end - minLength;\n                    }\n\n                    if (time < 0) {\n                        time = 0;\n                    }\n                } else if (resize === 'end') {\n                    if (time < this.start + minLength) {\n                        // Calculate the end time based on the min length of the region.\n                        time = this.start + minLength;\n                        delta = time - (this.end + (time - startTime));\n                    }\n\n                    if (time > duration) {\n                        time = duration;\n                    }\n                }\n            }\n\n            if (!delta) {\n                delta = time - startTime;\n            }\n\n            startTime = time;\n\n            // Drag\n            if (this.drag && drag) {\n                updated = updated || !!delta;\n                this.onDrag(delta);\n            }\n\n            // Resize\n            if (this.resize && resize) {\n                updated = updated || !!delta;\n                this.onResize(delta, resize);\n            }\n\n            if (\n                this.scroll && container.clientWidth < this.wrapper.scrollWidth\n            ) {\n                // Triggering edgescroll from within edgeScrollWidth\n                let x = orientedEvent.clientX;\n\n                // Check direction\n                if (x < wrapperRect.left + this.edgeScrollWidth) {\n                    scrollDirection = -1;\n                } else if (x > wrapperRect.right - this.edgeScrollWidth) {\n                    scrollDirection = 1;\n                } else {\n                    scrollDirection = null;\n                }\n\n                if (scrollDirection) {\n                    edgeScroll(event);\n                }\n            }\n        };\n\n        this.element.addEventListener('mousedown', onDown);\n        this.element.addEventListener('touchstart', onDown);\n\n        document.body.addEventListener('mousemove', onMove);\n        document.body.addEventListener('touchmove', onMove, {passive: false});\n\n        document.addEventListener('mouseup', onUp);\n        document.body.addEventListener('touchend', onUp);\n\n        this.on('remove', () => {\n            document.removeEventListener('mouseup', onUp);\n            document.body.removeEventListener('touchend', onUp);\n            document.body.removeEventListener('mousemove', onMove);\n            document.body.removeEventListener('touchmove', onMove);\n        });\n\n        this.wavesurfer.on('destroy', () => {\n            document.removeEventListener('mouseup', onUp);\n            document.body.removeEventListener('touchend', onUp);\n        });\n    }\n\n    onDrag(delta) {\n        const maxEnd = this.wavesurfer.getDuration();\n        if (this.end + delta > maxEnd) {\n            delta = maxEnd - this.end;\n        }\n\n        if (this.start + delta < 0) {\n            delta = this.start * -1;\n        }\n\n        const eventParams = {\n            direction: this._getDragDirection(delta),\n            action: 'drag'\n        };\n\n        this.update({\n            start: this.start + delta,\n            end: this.end + delta\n        }, eventParams);\n    }\n\n    /**\n     * Returns the direction of dragging region based on delta\n     * Negative delta means region is moving to the left\n     * Positive - to the right\n     * For zero delta the direction is not defined\n     * @param {number} delta Drag offset\n     * @returns {string|null} Direction 'left', 'right' or null\n     */\n    _getDragDirection(delta) {\n        if (delta < 0) {\n            return 'left';\n        }\n        if (delta > 0) {\n            return 'right';\n        }\n        return null;\n    }\n\n    /**\n     * @example\n     * onResize(-5, 'start') // Moves the start point 5 seconds back\n     * onResize(0.5, 'end') // Moves the end point 0.5 seconds forward\n     *\n     * @param {number} delta How much to add or subtract, given in seconds\n     * @param {string} direction 'start 'or 'end'\n     */\n    onResize(delta, direction) {\n        const duration = this.wavesurfer.getDuration();\n        const eventParams = {\n            action: 'resize',\n            direction: direction === 'start' ? 'left' : 'right'\n        };\n\n        if (direction === 'start') {\n            // Check if changing the start by the given delta would result in the region being smaller than minLength\n            if (delta > 0 && this.end - (this.start + delta) < this.minLength) {\n                delta = this.end - this.minLength - this.start;\n            }\n\n            // Check if changing the start by the given delta would result in the region being larger than maxLength\n            if (delta < 0 && this.end - (this.start + delta) > this.maxLength) {\n                delta = this.end - this.start - this.maxLength;\n            }\n\n            if (delta < 0 && (this.start + delta) < 0) {\n                delta = this.start * -1;\n            }\n\n            this.update({\n                start: Math.min(this.start + delta, this.end),\n                end: Math.max(this.start + delta, this.end)\n            }, eventParams);\n        } else {\n            // Check if changing the end by the given delta would result in the region being smaller than minLength\n            if (delta < 0 && this.end + delta - this.start < this.minLength) {\n                delta = this.start + this.minLength - this.end;\n            }\n\n            // Check if changing the end by the given delta would result in the region being larger than maxLength\n            if (delta > 0 && this.end + delta - this.start > this.maxLength) {\n                delta = this.maxLength - (this.end - this.start);\n            }\n\n            if (delta > 0 && (this.end + delta) > duration) {\n                delta = duration - this.end;\n            }\n\n            this.update({\n                start: Math.min(this.end + delta, this.start),\n                end: Math.max(this.end + delta, this.start)\n            }, eventParams);\n        }\n    }\n\n    onContentBlur(event){\n        const {text: oldText} = this.data || {};\n        const text = event.target.innerText;\n        const data = {...this.data, text };\n        const eventParams = {action: 'contentEdited', oldText, text};\n        this.update({data}, eventParams);\n    }\n\n    onContentClick(event){\n        event.stopPropagation();\n    }\n\n    onRemove(event){\n        event.stopPropagation();\n        this.remove();\n    }\n\n    updateHandlesResize(resize) {\n        let cursorStyle;\n        if (resize) {\n            cursorStyle = this.vertical ? 'row-resize' : 'col-resize';\n        } else {\n            cursorStyle = 'auto';\n        }\n\n        this.handleLeftEl && this.style(this.handleLeftEl, { cursor: cursorStyle });\n        this.handleRightEl && this.style(this.handleRightEl, { cursor: cursorStyle });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}