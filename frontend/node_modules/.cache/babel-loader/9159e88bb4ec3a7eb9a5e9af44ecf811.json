{"ast":null,"code":"export function urlToBuffer(url) {\n  const audioContext = new AudioContext();\n  return fetch(url).then(response => response.arrayBuffer()).then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer)).then(audioBuffer => {\n    const bufferSource = audioContext.createBufferSource();\n    bufferSource.buffer = audioBuffer;\n    return bufferSource;\n  }).catch(error => console.log(error)); // return buffer;\n}\nexport function cropBuffer(buffer, startTime, endTime) {\n  const audioContext = buffer.context;\n  const croppedBuffer = audioContext.createBuffer(buffer.buffer.numberOfChannels, Math.floor((endTime - startTime) * buffer.buffer.sampleRate), buffer.buffer.sampleRate);\n\n  for (let channel = 0; channel < buffer.buffer.numberOfChannels; channel++) {\n    const channelData = new Float32Array(Math.floor((endTime - startTime) * buffer.buffer.sampleRate));\n    buffer.buffer.copyFromChannel(channelData, channel, Math.floor(startTime * buffer.buffer.sampleRate));\n    croppedBuffer.copyToChannel(channelData, channel, 0);\n  }\n\n  return croppedBuffer;\n} //function to get wav bytes from buffer source\n\nexport function bufferToWav(buffer) {\n  let channelData = [],\n      totalLength = 0,\n      channelLength = 0;\n\n  for (let i = 0; i < buffer.numberOfChannels; i++) {\n    channelData.push(buffer.getChannelData(i));\n    totalLength += channelData[i].length;\n    if (i === 0) channelLength = channelData[i].length;\n  } // interleaved\n\n\n  const interleaved = new Float32Array(totalLength);\n\n  for (let src = 0, dst = 0; src < channelLength; src++, dst += buffer.numberOfChannels) {\n    for (let j = 0; j < buffer.numberOfChannels; j++) interleaved[dst + j] = channelData[j][src]; //interleaved[dst] = left[src];\n    //interleaved[dst + 1] = right[src];\n\n  } // get WAV file bytes and audio params of your audio source\n\n\n  const wavBytes = getWavBytes(interleaved.buffer, {\n    isFloat: true,\n    // floating point or 16-bit integer\n    numChannels: buffer.numberOfChannels,\n    sampleRate: 48000\n  });\n  return wavBytes;\n}\n\nfunction getWavBytes(buffer, options) {\n  const type = options.isFloat ? Float32Array : Uint16Array;\n  const numFrames = buffer.byteLength / type.BYTES_PER_ELEMENT;\n  const headerBytes = getWavHeader(Object.assign({}, options, {\n    numFrames\n  }));\n  const wavBytes = new Uint8Array(headerBytes.length + buffer.byteLength); // prepend header, then add pcmBytes\n\n  wavBytes.set(headerBytes, 0);\n  wavBytes.set(new Uint8Array(buffer), headerBytes.length);\n  return wavBytes;\n} // adapted from https://gist.github.com/also/900023\n// returns Uint8Array of WAV header bytes\n\n\nfunction getWavHeader(options) {\n  const numFrames = options.numFrames;\n  const numChannels = options.numChannels || 2;\n  const sampleRate = options.sampleRate || 44100;\n  const bytesPerSample = options.isFloat ? 4 : 2;\n  const format = options.isFloat ? 3 : 1;\n  const blockAlign = numChannels * bytesPerSample;\n  const byteRate = sampleRate * blockAlign;\n  const dataSize = numFrames * blockAlign;\n  const buffer = new ArrayBuffer(44);\n  const dv = new DataView(buffer);\n  let p = 0;\n\n  function writeString(s) {\n    for (let i = 0; i < s.length; i++) {\n      dv.setUint8(p + i, s.charCodeAt(i));\n    }\n\n    p += s.length;\n  }\n\n  function writeUint32(d) {\n    dv.setUint32(p, d, true);\n    p += 4;\n  }\n\n  function writeUint16(d) {\n    dv.setUint16(p, d, true);\n    p += 2;\n  }\n\n  writeString(\"RIFF\"); // ChunkID\n\n  writeUint32(dataSize + 36); // ChunkSize\n\n  writeString(\"WAVE\"); // Format\n\n  writeString(\"fmt \"); // Subchunk1ID\n\n  writeUint32(16); // Subchunk1Size\n\n  writeUint16(format); // AudioFormat https://i.stack.imgur.com/BuSmb.png\n\n  writeUint16(numChannels); // NumChannels\n\n  writeUint32(sampleRate); // SampleRate\n\n  writeUint32(byteRate); // ByteRate\n\n  writeUint16(blockAlign); // BlockAlign\n\n  writeUint16(bytesPerSample * 8); // BitsPerSample\n\n  writeString(\"data\"); // Subchunk2ID\n\n  writeUint32(dataSize); // Subchunk2Size\n\n  return new Uint8Array(buffer);\n}","map":{"version":3,"sources":["/Users/niteshsingh/Desktop/Voimo/frontend/src/assests/assist.js"],"names":["urlToBuffer","url","audioContext","AudioContext","fetch","then","response","arrayBuffer","decodeAudioData","audioBuffer","bufferSource","createBufferSource","buffer","catch","error","console","log","cropBuffer","startTime","endTime","context","croppedBuffer","createBuffer","numberOfChannels","Math","floor","sampleRate","channel","channelData","Float32Array","copyFromChannel","copyToChannel","bufferToWav","totalLength","channelLength","i","push","getChannelData","length","interleaved","src","dst","j","wavBytes","getWavBytes","isFloat","numChannels","options","type","Uint16Array","numFrames","byteLength","BYTES_PER_ELEMENT","headerBytes","getWavHeader","Object","assign","Uint8Array","set","bytesPerSample","format","blockAlign","byteRate","dataSize","ArrayBuffer","dv","DataView","p","writeString","s","setUint8","charCodeAt","writeUint32","d","setUint32","writeUint16","setUint16"],"mappings":"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","sourcesContent":["export function urlToBuffer(url) {\n  const audioContext = new AudioContext();\n  return fetch(url)\n    .then((response) => response.arrayBuffer())\n    .then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer))\n    .then((audioBuffer) => {\n      const bufferSource = audioContext.createBufferSource();\n      bufferSource.buffer = audioBuffer;\n      return bufferSource\n    })\n    .catch((error) => console.log(error));\n    // return buffer;\n}\n\nexport function cropBuffer(buffer,startTime,endTime){\n    const audioContext = buffer.context;\n    const croppedBuffer = audioContext.createBuffer(\n      buffer.buffer.numberOfChannels,\n      Math.floor((endTime - startTime) * buffer.buffer.sampleRate),\n      buffer.buffer.sampleRate\n    );\n    for (let channel = 0; channel < buffer.buffer.numberOfChannels; channel++) {\n      const channelData = new Float32Array(\n        Math.floor((endTime - startTime) * buffer.buffer.sampleRate)\n      );\n      buffer.buffer.copyFromChannel(\n        channelData,\n        channel,\n        Math.floor(startTime * buffer.buffer.sampleRate)\n      );\n      croppedBuffer.copyToChannel(channelData, channel, 0);\n    }\n    return croppedBuffer;\n}\n\n//function to get wav bytes from buffer source\nexport function bufferToWav(buffer) {\n  let channelData = [],\n    totalLength = 0,\n    channelLength = 0;\n\n  for (let i = 0; i < buffer.numberOfChannels; i++) {\n    channelData.push(buffer.getChannelData(i));\n    totalLength += channelData[i].length;\n    if (i === 0) channelLength = channelData[i].length;\n  }\n\n  // interleaved\n  const interleaved = new Float32Array(totalLength);\n\n  for (\n    let src = 0, dst = 0;\n    src < channelLength;\n    src++, dst += buffer.numberOfChannels\n  ) {\n    for (let j = 0; j < buffer.numberOfChannels; j++)\n      interleaved[dst + j] = channelData[j][src];\n    //interleaved[dst] = left[src];\n    //interleaved[dst + 1] = right[src];\n  }\n  // get WAV file bytes and audio params of your audio source\n  const wavBytes = getWavBytes(interleaved.buffer, {\n    isFloat: true, // floating point or 16-bit integer\n    numChannels: buffer.numberOfChannels,\n    sampleRate: 48000,\n  });\n  return wavBytes;\n}\n\nfunction getWavBytes(buffer, options) {\n  const type = options.isFloat ? Float32Array : Uint16Array;\n  const numFrames = buffer.byteLength / type.BYTES_PER_ELEMENT;\n\n  const headerBytes = getWavHeader(Object.assign({}, options, { numFrames }));\n  const wavBytes = new Uint8Array(headerBytes.length + buffer.byteLength);\n\n  // prepend header, then add pcmBytes\n  wavBytes.set(headerBytes, 0);\n  wavBytes.set(new Uint8Array(buffer), headerBytes.length);\n\n  return wavBytes;\n}\n\n// adapted from https://gist.github.com/also/900023\n// returns Uint8Array of WAV header bytes\nfunction getWavHeader(options) {\n  const numFrames = options.numFrames;\n  const numChannels = options.numChannels || 2;\n  const sampleRate = options.sampleRate || 44100;\n  const bytesPerSample = options.isFloat ? 4 : 2;\n  const format = options.isFloat ? 3 : 1;\n\n  const blockAlign = numChannels * bytesPerSample;\n  const byteRate = sampleRate * blockAlign;\n  const dataSize = numFrames * blockAlign;\n\n  const buffer = new ArrayBuffer(44);\n  const dv = new DataView(buffer);\n\n  let p = 0;\n\n  function writeString(s) {\n    for (let i = 0; i < s.length; i++) {\n      dv.setUint8(p + i, s.charCodeAt(i));\n    }\n    p += s.length;\n  }\n\n  function writeUint32(d) {\n    dv.setUint32(p, d, true);\n    p += 4;\n  }\n\n  function writeUint16(d) {\n    dv.setUint16(p, d, true);\n    p += 2;\n  }\n\n  writeString(\"RIFF\"); // ChunkID\n  writeUint32(dataSize + 36); // ChunkSize\n  writeString(\"WAVE\"); // Format\n  writeString(\"fmt \"); // Subchunk1ID\n  writeUint32(16); // Subchunk1Size\n  writeUint16(format); // AudioFormat https://i.stack.imgur.com/BuSmb.png\n  writeUint16(numChannels); // NumChannels\n  writeUint32(sampleRate); // SampleRate\n  writeUint32(byteRate); // ByteRate\n  writeUint16(blockAlign); // BlockAlign\n  writeUint16(bytesPerSample * 8); // BitsPerSample\n  writeString(\"data\"); // Subchunk2ID\n  writeUint32(dataSize); // Subchunk2Size\n\n  return new Uint8Array(buffer);\n}\n"]},"metadata":{},"sourceType":"module"}